# 每日总结

## 2022年4月8日：

> 今天做了设计模式的 观察者模式， 策略模式，
> 
> 操作系统如何通过虚拟地址找到物理地址，通过分页，分段的方式
> 
> 算法题刷了 树方面的知识，树的镜像，判断是否为**二叉搜索树**

<br/>

## 2022年4月9日:

> 打了蓝桥杯，两个大题错了， 其他还好，希望有省一

<br/>

## 2022年4月10日:

> 算法题：确定一颗二叉树，前缀和+哈希(a – k) = b的思想，atoi，to_string，
> 
> 操作系统，还是不太清楚分页和多级分页有什么好处hhh
> 
> 打算过一下stl源码

<br/>

## 2022年4月11,12日:

> 写了几道数的算法题，学了操作系统进程线程那块，发现难顶啊，怎么去调度，比页面置换要难理解

<br/>

## 2022年4月13日:

> 算法： 将答案记忆化，
> 
> 操作系统： 还是进程，发现要去看看一些博主的文章，看着视频都有一定困

<br/>

## 2022年4月14日:

> 算法：
> 
> ​ 最近公共祖先，利用后序遍历来判断左右情况，
> 
> ​ 以及在二叉搜索树中寻找祖先的优化技巧
> 
> ​ 二叉树中寻找最大路径和， 也是利用后序，看选左还是右，或者左右一起
> 
> PyQt：
> 
> ​ 还没弄成功，今晚叫同学教一下，不过也发现，做这些，代码别人已经实现好了，只需要调用就可以了
> 
> 今晚见个女孩子（说实话，人家还挺可爱，爱笑，话挺多，但感觉自己说不出什么话出来，嘴太笨了，没有进一步的情感暗示，md，千万不要做一些让女生反感的事情，提升自己的讲话的故事性）

<br/>

## 2022年4月15日:

> 算法： 一道回溯题，加上又撤销，以及栈
> 
> 操作系统： 就一些进程之间的通信，共享资源类的，信号量，有点迷迷糊糊
> 
> 发现有一些文件上链接有点问题，这就很迷，写的好好的，发到别人那去就运行不了，艹

<br/>

## 2022年4月16日:

> 算法： 也就一些简单的模拟+贪心
> 
> 操作系统： 弄到了文件，先过一遍吧，实在迷
> 
> stl源码： 实现起来还是很庞大， 应该是自己水平还不太行
> 
> sql的round(val, 位)， current_data(),
> 
> 其实这两天学的都迷，就想着撩妹了，要找回节奏了

<br/>

## 2022年4月19日:

> 今天学了点qt，不过环境还没装上，难受，大致就是控件之间通过信号和槽来进行消息传递
> 
> 通过视频也学到一个知识点： 成员函数指针，必须要在实例化后才可以调用，与全局函数的不同，因为全局函数会在程序一开始就有内存地址，而成员函数要实例化分配内存才可以调用。。
> 
> 以及c++异常捕获的写法，抛出异常析构不执行，有点危险...

<br/>

## 2022年4月20日:

> Qt: 环境搭好了， 也写了一些控件，现在基本感觉，有文档写就行，不过还没和c++代码结合起来，除了通过信号量去调用相关代码
> 
> 其实说好到月底要把操作系统过一遍的也没搞好，这个月光想泡妞去了
> 
> 每天写一个设计模式，发现什么情况都会有设计模式的出现

<br/>

## 2022年4月21日:

> Qt: 学了一些事件， 系统自动调用，概念还不太清，回宿舍看几篇文章先
> 
> 算法： 弄了个二分，迷迷糊糊的，不知道哪错了

<br/>

## 2022年4月22日:

> Qt: 项目
> 
> 算法： 左右指针，三个数的和最接近target

<br/>

## 2022年4月24日:

> 怎么又少了一天， 害
> 
> Qt：算是基本掌握里面的实现，都是通过信号连接彼此来达到联合的作用，明天试试用这个来把上次python的作用bim来写了
> 
> 算法： 没啥，快速幂，偶数就双倍，奇数多乘一次自己
> 
> c++外挂： 就是通过找到汇编，因为高级语言都会转成汇编，通过修改内存指令去达到更改数据的效果，

<br/>

## 2022年4月25日:

> Qt: 写完了bim，已发布，
> 
> c++：private继承： 就是说子类里面可以调用父类的东西，但是在外界不能访问其父类函数，public继承代表is a，

<br/>

## 2022年4月26日:

> C++: 有关虚函数表地址共享的问题， 构造和拷贝构造函数在什么时候会生成默认，
> 
> * 不过有点疑问就说，成员函数地址是在 对象实例化后存在，还是，程序一运行它就存在？（编译就知道了，在构造函数之前就已经赋值了）

<br/>

## 2022年4月27日:

> c++: 虚基类的学习， 继承的父类，虚父类和父类数据分开，
> 
> 算法： 发现重载运算符有点问题，哈夫曼，

<br/>

## 2022年4月28日:

> c++:
> 
> * 对于虚基类的虚函数有了更充分的认识，已经this指针偏移的作用，还有类中的函数都会自带一个this指针，所以类的函数是要实例化对象才存在，
> 
> 蓝桥杯出成绩，省一， 希望没有疫情去趟北京！
> 
> 5月份正式开始搞操作系统

<br/>

## 2022年4月29日:

> C++:
> 
> * 算是过了一轮对象模型，明天休息，脑子过过虚函数的调用规则，争取写一篇完整的文章
> 
> 下个星期开始走linux了， 环境已经搭好

<br/>

## 2022年4月30日:

> C++:
> 
> * 已经把对象模型总结弄出来了， 虚函数虚基类，无非就是通过this指针的移动来调用的
> 
> Linux：
> 
> * 真的麻烦啊~~~ 真的烦！！， 什么东西都没有，百度也没用，真的烦！！
> 
> 明天休息，调整。。

<br/>

## 2022年5月4日:

> C++:
> 
> * 智能指针的运用， share_ptr, weak_ptr, uninque_ptr,
> * 明天开始多线程， 和模板
> * 感觉还是打好这里的基础
> 
> 算法：
> 
> * 明天写一下 根据中序和层序创建二叉树
> 
> 看了一下linux，唉，头痛这个， 。。。。

<br/>

## 2022年5月5日:

> C++:
> 
> * 多线程， mutex， unique_lock, lock_guard, 原子atomic， 递归mutex， 异步的async，

<br/>

## 2022年5月6日:

> C++:
> 
> * 就大概看了函数对象
> 
> Linux：
> 
> * 算是知道哪里出问题了，网络的问题，导致下载不了包，接下来的计划大概就是c++模板， 还有linux操作系统

<br/>

## 2022年5月7日:

> 操作系统：
> 
> * 知道了操作系统就是不断去调度进程，提高cpu处理效率，进程间就是通过pcb， 进程中又分用户级线程，内核级线程，通过tcb来控制，不同进程间的内存地址是不同的，是虚拟内存，有不同的映射表，明天回顾一下这里的线程和进程

<br/>

## 2022年5月8日:

> c++：
> 
> * 友元成员函数要注意，前向声明，以及函数要在类外实现，因为你要知道这个函数到底在不在
> * 模板：传进去的类型要对， 多写吧，比如变量模板，
> 
> 操作系统：
> 
> * 内核级线程中内核也是通过换tcb来切到其他内核中的栈，内核中的栈再返回用户级的栈
> 
> 明天把中序和层序构造树给写了，再刷一遍内核级线程的视频，争取下周五之前进到网络编程

<br/>

## 2022年5月9日:

> 操作系统：
> 
> * 进程的调度，信号量，临界区，死锁，内存分页，分段，明天了解一下内存这方面的东西，进程这块稀里糊涂，毕竟还没写过这些代码，不知道原理是什么，记概念没用

<br/>

## 2022年5月10日:

> 操作系统：
> 
> * 学了内存管理，段页， 有点小疑问，当两个进程访问一个*p的时候，一个进程改了这个数据，发现这两个数据怎么同步，或者说，会不会导致不一致

<br/>

## 2022年5月11日:

> 没有特别新鲜，帮别人做题，还要晚修。。。1000+

<br/>

## 2022年5月13日:

> c++：
> 
> * 知道了萃取的原理，就是通过模板的泛化来实现，
> * 万能引用

<br/>

## 2022年5月15日:

> 网络编程：
> 
> * 基本的函数使用，比如3次握手，4次挥手，
> * socket， bind， listen，accept，read，write close
> * socket， connect， read， write， close

<br/>

## 2022年5月16日:

> 网络编程：
> 
> * 写了一个server 和 client， 发现原理不太明白，不知道为什么这样就能连接，希望接下来可以回答这个问题

<br/>

## 2022年5月23日:

> 颓废了好几天，认识了一个女孩子，还不错，不过感觉还是不太适合自己，先慢慢接触吧
> 
> 还是往网络编程方向去学习，发现都是在调用相关的api， 明天打算看看tcp/ip网络编程这本书

<br/>

## 2022年5月24日:

> 网络编程：
> 
> * learn函数： 就是设置监听队列， 让connect的函数进入
> * accept： 产生套接字与客户端连接
> * connect： 等到服务器接受连接才返回，并且产生ip地址以及端口号
> * read write 都是往缓冲区读数据，写数据

<br/>

## 2022年5月27日:

> 又歇菜了两天~~， 很特别的几天，谢谢她
> 
> 网络编程：
> 
> * udp实现服务器， 也可以通过connect函数绑定，这样就不用每次都产生一次地址，
> * time_wait状态： 在fin包发出去后，如果对方未接收到，此时会重传，不然对端永远无法接收到

<br/>

## 2022年5月28日:

> 今天有一位兄弟通过我的文章找到了我，还是有点兴奋，但是不知道有没有帮到他哈哈哈
> 
> 网络编程：
> 
> * 围绕在进程间的通信这块，了解了僵尸进程，就是父进程没有接受到子进程的返回值，所以就要想办法去传递返回值来销毁子进程，比如用wait， waitpid， 信号，
> * fork出的子进程是执行fork后面的代码，但是复制了父进程的资源，
> * 还有一个小问题，怎么通过一个服务端来和多个客户端进行通信，除了io复用和udp，进程线程；时间轮询我会出现错误，具体在csdn有发布，

<br/>

## 2022年5月29日:

> 被一个傻女孩弄的提前结束一天
> 
> 网络编程：
> 
> * select io复用实现服务器， 一开始就设定监听数，但是要注意，每次调用select是总数+1，因为是从0开始，其他的都没什么，就是被这个小bug拖了点时间，
>   
>   FD_ZERO(), FD_SET(), SELECT(NUM+1, X.X.X.X), FD_ISSET(), FD_CLR();
>   

<br/>

## 2022年5月30日:

> 今天发现彻底懵了， udp和tcp，都是建立在多个ip地址与其单个服务端进行通讯的
> 
> 今天参加了一个项目起头，发现是我格局小了，同级的还是有很多强者的，不能自以为是了，还想抱着过去学一学的心态，人家都能做出来了，你没实力还过去凑热闹。。。
> 
> 网络编程：
> 
> * 懵在了 到达accept是支持连接多个套接字？，怎么会有迭代？， 明天好好搞清楚，以及多线程是怎么实现服务器的

<br/>

## 2022年6月1日:

> * 知道了多线程是怎么去操作的了，就是通过一些互斥量，信号量来控制一个线程的读写次序，我满足就执行，
> * 更新了关于网络api的博客
> * 今晚看看io模型有点迷异步和同步

<br/>

## 2022年6月2日:

> 明天端午，又要歇菜。。。
> 
> 网络编程：
> 
> * 定时器？？ 没怎么明白原理
>   
>   发现游双这本linux高性能服务器编程看的没有tcp/ip网络编程那么好懂。。。
>   

<br/>

## 2022年6月8日:

> 昨天就有开始恢复了，今天开始了老王的项目，学了几个函数，比如怎么读配置文件，指针的操作，地址的差值去覆盖，

## 2022年6月9日:

> 老王的通讯架构： 配置文件的读写，日志打印
> 
> > 其实就是自己重新定义了一个类似printf的函数，知道了一下内存赋值的操控方法，
> > 
> > ui64 = (uint64_t)va_arg(args, u_int); 这个函数就nb，直接把类型直接转出来，
> > 
> > 这里的实现其实都是通过字符串的处理，比如浮点数，是通过分开小数点前，小数点后去处理的。
> > 
> > 字符指针的跳转是看什么时候有'\0'就结束，不是说跳它本身结构的长度，因为指针都是4个字节,像最后一个for循环，赋值是整个赋值，但是有'\0'
> > 
> >     #include <iostream>
> >     #include <algorithm>
> >     using namespace std;
> >     
> >     int main() {
> >     
> >         const char* s[5] = { "1","22","333","4444","55555"};
> >     
> >         int i;
> >         int g_environlen = 0;
> >     
> >         for (i = 0; i < 5; i++)
> >         {
> >             g_environlen += strlen(s[i]) + 1; //+1是因为末尾有\0,是占实际内存位置的，要算进来
> >         } //end for
> >     
> >         //这里无需判断penvmen == NULL,有些编译器new会返回NULL，有些会报异常，但不管怎样，如果在重要的地方new失败了，你无法收场，让程序失控崩溃，助你发现问题为好； 
> >         char *gp_envmem = new char[g_environlen];
> >         memset(gp_envmem, 0, g_environlen);  //内存要清空防止出现问题
> >     
> >         char* ptmp = gp_envmem;
> >     
> >         //把原来的内存内容搬到新地方来
> >         for (i = 0; s[i]; i++)
> >         {
> >             size_t size = strlen(s[i]) + 1; //不要拉下+1，否则内存全乱套了，因为strlen是不包括字符串末尾的\0的
> >             strcpy(ptmp, s[i]);      //把原环境变量内容拷贝到新地方【新内存】
> >             s[i] = ptmp;            //然后还要让新环境变量指向这段新内存
> >             ptmp += size;
> >         }
> >         return 0;
> >     }
> >     
> 
> 多调试代码，发现内存这东西，还挺有意思，不断跳转跳转，
